[HOTFIX] Fix session persistence and response token limits for multi-turn interviews

## Problem
- SessionManager defaults to persistent_mode=False, breaking multi-turn conversations
- Claude provider max_tokens=768 is way too short for system design discussions
- Gemini provider has no max_tokens configured at all

## Changes Required

### 1. app/session_manager.py
Change the default value in `__init__`:
```python
self._persistent_mode: bool = True  # Was False
```

### 2. app/providers/claude_provider.py  
In ClaudeConfig dataclass, bump max_tokens:
```python
@dataclass(frozen=True)
class ClaudeConfig:
    """Configuration for Claude API calls."""
    model: str = "claude-sonnet-4-5-20250929"
    max_tokens: int = 2048  # Was 768
    temperature: float = 0.7
```

### 3. app/providers/gemini_provider.py
Add max_tokens to the generate_content_config. In stream_response method, update the config creation:
```python
config = types.GenerateContentConfig(
    system_instruction=system_prompt,
    max_output_tokens=2048,
)
```

## Verification
- Session should persist across F9 audio inputs, F8 text inputs, and screenshot analysis
- Responses should be able to handle longer system design explanations without truncation

## Code Standards

Write code that looks inevitable. Follow these constraints:

**Restraint**
- Solve it in one file if possible
- No abstractions until the third time you need them
- No classes if functions will do
- No inheritance - use composition

**Functions**
- Max 25 lines, aim for 15
- One level of nesting max
- Name describes exactly what it does: `extract_billable_hours()` not `process_data()`
- Input → transform → output. No side effects unless that's the point.

**Files**
- Max 200 lines for new files
- One clear responsibility
- If you're adding a second "system" to a file, stop and split

**No Ceremony**
- No AbstractFactory, no IServiceProvider, no Manager classes
- No code "just in case" - solve the actual problem
- Delete commented-out code, don't keep it

**Data**
- Use dataclasses or plain dicts, not classes with only __init__ and getters
- Data flows obviously - reader should predict what happens next
- No global state

The best code is code you delete. Every line is a liability.
